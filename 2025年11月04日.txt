一、总体介绍
    0、总目标：学会 AOP 的使用方式
    1、提出问题：方法体内部有重复的代码如何抽取出来
    2、解决方案：代理模式
        由 Java 原生 API提供：静态代理、动态代理（作为例子引入，代码本身不需要掌握）
        由 Spring 框架提供：AOP
    3、AOP 概念：切面、通知、切入点、切面优先级
    4、AOP 语法：创建切面、编写通知方法、统一管理切入点表达式、设置切面优先级
    5、作业
        (1)使用写好的动态代理类往有需要的方法上套
        (2)AOP语法练习：创建切面类
        (3)AOP语法练习：在切面类中编写通知方法
        (4)AOP语法练习：给通知方法设置切入点表达式
        (5)AOP语法练习：上述代码测试
        (6)AOP语法练习：统一管理切入点表达式
        (7)AOP语法练习：切入点表达式语法
            execution
            @annotation
        (8)AOP语法练习：切面优先级

二、动态代理部分
    1、目标：
        (1)把目标方法中，非核心业务剥离出来，实现核心业务和非核心业务的解耦
        (2)用剥离出来的非核心业务往有需要的目标方法上套，对目标方法的增强
    2、技术实现
        (1)静态代理：能够实现代理模式，但是只能针对一个接口开发功能，不具备通用性
        (2)动态代理：在实现代理模式的基础上，具备通用性，任何接口都能够进行代理
            例如：不管什么接口的实现类，我们都可以给它附加打印日志的功能
    3、掌握的要求
        大家只需要拿写好的动态代理类，往接口实现类（目标对象）上套，体会代理模式即可
        具体的代理技术不要求

三、AOP部分
    1、概念的含义
        通俗来说：其实 AOP 就是使用框架实现代理模式
        名词解释：AOP（Aspect Oriented Programming）面向切面编程
        功能作用：一枚硬币的两面
            (1)代码简化：把原本分散在各个方法内部的通用性、重复性的代码抽取出来，放在代理类（AOP里面叫切面类）中
            (2)代码增强：拿切面类中封装的非核心业务逻辑套用到有需要的目标方法上

    2、常用概念
        通知：英文单词 advice
        前置通知：目标方法执行之前被调用
        返回通知：目标方法成功结束、返回之后
        异常通知：目标方法失败结束、抛出异常之后
        后置通知：目标方法最终结束之后
        环绕通知：使用整个 try {} catch(){} finally{} 结构包裹目标方法的执行
        通知方法：前面介绍的任何一个“通知”要实现具体功能，都必须在一个方法中编写代码，这个方法就是通知方法
        切面类：包含通知方法的类，就是切面类
        切入点：通过在切入点定义切入点表达式，把具体的通知方法作用到目标方法上，它决定了通知方法对哪一个目标方法生效
        切入点表达式：在程序中通过编写切入点表达式告诉框架，当前切入点具体对应的是哪一个或哪一组方法

    3、Spring 中 AOP 底层使用的技术
        Spring 5及以前
            目标类有实现接口：底层使用 JDK 自带的动态代理
            目标类没有实现接口：底层使用 CGLIB
        Spring 6开始：不管目标类有没有实现接口，都是 CGLIB

    4、JDK 动态代理和 CGLIB 有什么区别？
        JDK 动态代理生成的代理类和目标类实现相同的接口（拜把子）
        CGLIB 生成的代理类继承目标类（认干爹）

    5、AspectJ
        JDK 动态代理、CGLIB、AspectJ 它们都是“代理模式”的具体技术方案
        AspectJ 的实现机制是把代理逻辑织入到目标类编译结果的字节码文件中
            开发层面来说：动态
            运行层面来说：静态
        Spring 使用了 AspectJ 中的注解，并没有使用 AspectJ 的整个技术方案

    6、SpringBoot 和 junit 整合
        (1)关键点：测试类必须放在 Spring 能够扫描到的地方
        (2)语法：在类上标记 @SpringBootTest 注解，然后测试方法还是一样使用 @Test 注解标记
        (3)福利：整合之后凡是 IoC 容器中的 bean 对象就都可以在测试类中自动装配进来使用

    7、切面类语法要求
        (1)切面类本身也必须放入 IoC 容器
        (2)使用 @Aspect 注解把这个类标记为切面类

    8、被代理的目标类：目标类也必须放入 IoC 容器

    9、通知方法
        每一个通知方法都需要加对应的注解，所有通知方法注解都必须通过 value 属性设置切入点表达式
        前置通知：@Before注解（全类名：org.aspectj.lang.annotation.Before）
        返回通知：@AfterReturning
        异常通知：@AfterThrowing
        后置通知：@After
        环绕通知：@Around

    10、测试类
        仅仅只是注入了业务组件（例如：Calculator 对象），在测试方法中，也没有关心代理、切面、通知……，仍然还是像什么都没发生一样正常调用业务方法
        这一点就是框架诸多好处之一：非侵入式——框架提供了额外的功能，但是表面上我们使用时感觉不到；框架尽可能少的改变业务代码

    11、获取细节信息
        (1)每一个通知方法都需要获取目标方法名称
            通知方法声明一个 JoinPoint 类型的形参
            在通知方法的方法体中调用 JoinPoint 对象获取目标方法的签名，再通过签名获取方法名
            签名：关于目标方法的一切，例如所在类型的全类名、方法名、权限修饰符、返回值类型等等

        (2)前置通知：通过 JoinPoint 对象获取实参数组

        (3)返回通知：获取目标方法的返回值
            给通知方法声明一个形参，用来接收目标方法的返回值
            在 @AfterReturning 注解中设置参数名称，具体做法是把形参名称赋值给 returning 属性
                returning = "returnValue"

        (4)异常通知：获取目标方法抛出的异常对象
            给通知方法声明一个形参，用来接收目标方法抛出的异常对象
            在 @AfterThrowing 注解中设置参数名称，具体做法是把形参名称赋值给 throwing 属性
                throwing = "throwable"

        (5)环绕通知：让通知方法声明一个 ProceedingJoinPoint 类型的形参

    12、重用切入点表达式
        (1)重用的好处：当多个通知方法指向同一个目标时，切入点表达式就应该集中写在一个地方，实现“一处修改，处处生效”
        (2)具体的做法：
            [1]声明一个方法，在方法上标记@PointCut注解
            [2]在@PointCut注解的value属性中设置切入点表达式
            [3]在通知方法中引用@PointCut注解标记的方法
                方法在本类中：@After(value = "pointCutExpression()")
                方法在其它类中：@Before(value = "com.atguigu.spring.api.point_cut.DemoPointCut.globalPointCut()")

    13、环绕通知内部具体写法
        (1)调用目标方法：org.aspectj.lang.ProceedingJoinPoint.proceed(java.lang.Object[])
        (2)获取调用目标方法时需要传入的实参数组：org.aspectj.lang.JoinPoint.getArgs()
        (3)通常来说，在环绕通知中调用目标方法得到目标方法的返回值之后，都要返回给外部调用者
        (4)相比较来说，前置通知没有能力根据条件决定是否调用目标方法；但是环绕通知可以做到
            if(缓存中没有要查询的数据) {
                Xxx 查询结果数据 = joinPoint.proceed(args);
                把查询结果数据存入缓存
            }

    14、切面优先级
        (1)产生的原因：多个切面的通知方法套用上了同一个目标方法，所以就会有一个顺序的问题
        (2)关键点：切面优先级、执行顺序不是用“先后”描述的，而是用“内外”来描述的
            切面优先级高：外面（先开始、后结束）
            切面优先级低：里面（后开始、先结束）
        (3)控制：@Order注解设置一个整数，整数数值越小优先级越高

四、作业
    1、方案一：按上课顺序按个敲一遍
    2、方案二：
        (1)创建一个重用的切入点表达式（execution或annotation都可以）
        (2)基于重用的切入点表达式创建切面类和通知方法（除环绕通知外的四个通知）
            直接把相关细节都写上
        (3)测试
        (4)新创建一个切面，加入环绕通知
        (5)测试切面优先级
        (6)更换目标对象再测试一下
    3、关键：理解“套”这个字
        把“代理逻辑”往“目标方法”上套

五、友情提示
    1、传统代码写法：在一个线程内，编写代码时，按照从上到下的执行顺序来思考和编写
    2、AOP代码特点：代理逻辑包裹着目标逻辑，代码结构和传统代码不同