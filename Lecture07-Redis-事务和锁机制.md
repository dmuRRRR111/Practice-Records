[toc]

| 单词    | 音标       | 含义                                                         |
| ------- | ---------- | ------------------------------------------------------------ |
| multi   | /ˈmʌlti/   | 多；批量（Redis事务命令`MULTI`用于开启事务，之后输入的命令会被加入队列等待执行，直到`EXEC`被调用） |
| discard | /dɪˈskɑːd/ | 放弃；放弃（Redis事务命令`DISCARD`用于取消当前事务，清空已入队的命令，放弃执行事务） |
| exec    | /ɪɡˈzek/   | 执行（Redis事务命令`EXEC`用于执行`MULTI`开启的事务中所有入队的命令，返回各命令的执行结果） |
| QUEUED  | /kjuːd/    | 已排队（Redis中执行`MULTI`后，输入的命令会返回`QUEUED`状态，表示命令已加入事务队列等待执行） |
| watch   | /wɒtʃ/     | 监视（Redis命令`WATCH key`用于监视一个或多个键，若事务执行前被监视的键被修改，则事务会被打断，实现乐观锁） |

# Lecture05-Redis-事务和锁机制

# 一、Redis单线程机制

## 1、Redis的单线程核心

Redis 的单线程是指：**执行命令的核心逻辑是由一个线程完成的**。具体包括：

1. **命令执行线程**：Redis 处理客户端请求（如 SET、GET 等命令）的线程是单线程的
2. **内存操作**：对数据的读写操作在这同一个线程中完成
3. **IO 操作**：网络 IO 和键值对的存取操作都在这个线程中执行

<br/>

## 2、异步操作的实现

虽然核心逻辑是单线程的，但 Redis 确实有一些异步操作，这些操作主要包括：

1. **后台持久化**：RDB 快照和 AOF 重写操作
2. **异步删除**：当删除大键时（UNLINK 命令）
3. **关闭连接**：客户端连接断开时的清理工作
4. **集群数据同步**：Redis Cluster 中的数据迁移

<br/>

这些异步操作是通过以下方式实现的：

- **后台子进程**：如 RDB 持久化和 AOF 重写，使用 fork() 创建子进程
- **后台线程**：在 Redis 4.0 及以上版本中，引入了后台线程处理耗时操作
- **事件驱动**：部分异步操作使用事件循环机制实现

<br/>

## 3、为什么 Redis 选择单线程

Redis 选择单线程设计有以下几个原因：

1. **避免锁竞争**：单线程天然避免了多线程环境下的锁竞争问题
2. **高性能**：Redis 的性能瓶颈通常不是 CPU，而是内存和网络
3. **简化实现**：单线程设计使 Redis 的代码更简洁，系统架构更简单，更容易维护
4. **I/O 多路复用**：由于操作系统技术进步，让 Redis 能够使用 epoll 等 I/O 多路复用技术，充分利用单线程处理并发连接

<br/>

## 4、总结

Redis 的单线程结构可以这样理解：

- **单线程核心**：Redis 处理客户端请求的核心逻辑是单线程的，这是 Redis 高性能的关键
- **异步操作**：为了不阻塞核心线程，Redis 将一些耗时操作（如持久化、大键删除）放到后台进程或线程中执行
- **混合架构**：Redis 实际上是 "单线程核心 + 多线程辅助" 的混合架构

<br/>

# 二、原子性操作

> 在任何其它场合下，“原子”不作为它的本意出现时，都是“不可再分”的意思

## 1、概念

如果一个操作不能拆分成多个步骤，也就是说一个操作中只包含一个步骤，那么就说这个操作满足原子性

<br/>

## 2、举例

- 原子性操作：a = 5
- 非原子性操作：a++
  - 第一步：a + 1
  - 第二步：把 +1 的结果赋值给 a

<br/>

## 3、原子性与线程安全

在并发场景下，非原子性写操作无法保证线程安全——也就是无法保证数据计算的正确，那还了得？这是非常严重的问题！

那如果确实需要在并发场景下执行非原子性写操作怎么办呢？

答案是：加锁，加锁之后非原子性操作就会被封装成一个逻辑上的整体，从效果上相当于成了原子性操作

这里的含义是说：从最终计算结果的角度来看，这个逻辑上的整体在执行时只能有一个线程进来执行，能够保证数据计算的正确，所以从这个意义上说它满足原子性

```java
synchronized (this) {
    // 同步代码 ……
}
```

<br/>

## 4、Redis中的特殊性

Redis使用单线程执行命令，所以每一个命令——不管底层需要执行多少步骤，在执行过程中都满足原子性要求！

因为每一条命令在执行时都不会有其它线程的干扰

所以Redis单独执行任何一条命令，都满足原子性

<br/>

## 5、提出进一步问题

单条命令可以保证原子性，但是如果多条命令是一个逻辑上的整体，需要具备原子性怎么办？

![image-20250613192822281](./assets/image-20250613192822281.png)

比如上面图例中，我们希望黄色和蓝色命令能够各自独立执行，在执行过程中不受到其它命令的插入，不会被打乱顺序

![image-20250614101801246](./assets/image-20250614101801246.png)

<br/>

# 三、命令的批量执行

## 1、相关命令

| 命令名称 | 作用                             |
| -------- | -------------------------------- |
| multi    | 宣告开始把命令加入队列           |
| discard  | 对于已经加入队列的命令，放弃执行 |
| exec     | 执行队列中的每一条命令           |

<br/>

## 2、执行示例

```shell
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> set number 100
QUEUED
127.0.0.1:6379(TX)> incr number
QUEUED
127.0.0.1:6379(TX)> incr number
QUEUED
127.0.0.1:6379(TX)> EXEC
1) OK
2) (integer) 101
3) (integer) 102
127.0.0.1:6379> 
```

<br/>

## 3、为什么说上述操作满足原子性？

因为上面操作能够保证顺序，就是我们加入队列的命令，在执行过程中，不会有其它命令插入进来

![image-20250613193702580](./assets/image-20250613193702580.png)

<br/>

## 4、当批量执行遇到故障

### ①加入队列时出错

整个队列中的操作都不会执行

![image-20250613193820793](./assets/image-20250613193820793.png)

<br/>

### ②运行时出错

队列中的命令部分执行，没有回滚

![image-20250613194105676](./assets/image-20250613194105676.png)

<br/>

### ③Redis不支持回滚

- Redis认为：命令运行时报错属于开发过程中的编码错误，需要通过修正代码来解决，而不是回滚
- Redis不支持回滚就可以保证其内部结构足够简单，进而保证整体上执行效率更高、性能更好

<br/>

# 四、数据一致性保证

## 1、Watch监控key

![image-20250613195057452](./assets/image-20250613195057452.png)

<br/>

## 2、Watch效果说明

- 执行WATCH命令时：记录被监控key当前状态
- 执行EXEC命令时：检查被监控key此时此刻的状态
  - key指向的value没有被修改：正常执行队列中的命令
  - key指向的value被修改：放弃执行自己的事务操作

<br/>

# 五、悲观锁和乐观锁

## 1、悲观锁（排它锁）

- 对环境的判断：写操作占比高，碰撞几率高（所谓碰撞，就是并发写）
- 应对策略：用同步锁保护自身操作，自己的操作执行时，禁止其它线程执行
- 应用场景：关系型数据库，读写并重

<br/>

## 2、乐观锁（共享锁）

- 对环境的判断：读操作占比高，碰撞几率低
- 应对策略：不锁定数据，充分保证并发操作同时执行，最大化性能表现
- 万一碰撞：放弃自身操作，避免数据不一致
- 应用场景：非关系型内存数据库，以读为主

> WATCH命令实现乐观锁的机制：
>
> - 在监控key时，记录监控时key对应的vlaue
> - exec执行队列中的命令时，用WATCH监控记录的value和key当前实际的value相比较
>   - 相同：说明没有其它操作修改过这个数据，可以执行队列操作
>   - 不同：说明有其它操作修改过这个数据，放弃执行当前队列操作

> 另一种乐观锁的实现方式：基于版本号
>
> - 初始状态，数据附带版本号，初始版本：0
> - A线程想要修改数据，被要求出示操作所基于的版本，基于 0 版本号修改允许操作
> - A线程操作完成之后，版本号 +1，变成：1
> - B线程想要修改数据，被要求出示操作所基于的版本，基于 0 版本号，不允许修改
> - B线程读取最新版，用最新版把自己这边的数据更新，同时得到当前最新版本号：1
> - B线程再次申请修改，出示版本号：1，是最新版，可以修改
>
> 总结：在数据之外额外再附加一个版本号，只允许程序基于最新版修改

<br/>

# 六、Java客户端中的事务操作(了解)

```java
// 带WATCH的事务：实现乐观锁
public void transactionWithWatch(String key) {
    redisTemplate.execute(new SessionCallback<Object>() {
        @Override
        public <K, V> Object execute(RedisOperations<K, V> operations) throws DataAccessException {
            // 监视键
            operations.watch((K) key);

            // 获取当前值
            Object value = operations.opsForValue().get(key);

            // 开始事务
            operations.multi();

            // 修改值（示例：递增）
            operations.opsForValue().increment((K) key, 1);

            // 执行事务
            List<Object> results = (List<Object>) operations.exec();

            // 如果results为null，表示事务因冲突失败
            if (results == null) {
                // 重试逻辑...
                System.out.println("Transaction failed due to conflict, retry needed");
            }

            return results;
        }
    });
}
```

